<div class="zm-editable-content clearfix">
    <b><i><u>Builder模式</u></i></b><br>作用：如果你一个类有很多属性，创建的时候构造函数要赋很多值，那么可以考虑用Builder模式。<br>具体怎么定义Builder，可以看下：<a href="//link.zhihu.com/?target=https%3A//www.wuhuachuan.com/visitor/learning/article/getArticleDetail%3Fid%3Dc4bce04a-dc68-45ae-a15a-3d92c53358b6" class=" wrap external" target="_blank" rel="nofollow noreferrer">愿无岁月可回首<i class="icon-external"></i></a>。<br>以下是我在项目的单元测试的时候写到的（新手代码写得不太好，将就看一下吧）：<br><noscript>&lt;img src="https://pic2.zhimg.com/6aaab71c9ed12cb46cf9b390f728b10d_b.png" data-rawwidth="1688" data-rawheight="548" class="origin_image zh-lightbox-thumb" width="1688" data-original="https://pic2.zhimg.com/6aaab71c9ed12cb46cf9b390f728b10d_r.png"&gt;可以看到，当我在定义 InvestorHoldProduct 对象的时候，对于传入的参数，是不是很清晰了，productId，amount，profit 这些都是随你定义的。当然，你也可以用构造函数（对于这么多参数，这个是本人感觉最恶心的），你也可以先定义对象，然后一个一个的 set 进去（清晰也还可以，不过感觉没有 Builder 模式这样 高大上，^_^ ）。</noscript><img src="https://pic2.zhimg.com/6aaab71c9ed12cb46cf9b390f728b10d_b.png" data-rawwidth="1688" data-rawheight="548" class="origin_image zh-lightbox-thumb lazy" width="1688" data-original="https://pic2.zhimg.com/6aaab71c9ed12cb46cf9b390f728b10d_r.png" data-actualsrc="https://pic2.zhimg.com/6aaab71c9ed12cb46cf9b390f728b10d_b.png" data-lazyloaded="" style="width: 584px; height: 189.592px; display: block;">可以看到，当我在定义 InvestorHoldProduct 对象的时候，对于传入的参数，是不是很清晰了，productId，amount，profit 这些都是随你定义的。当然，你也可以用构造函数（对于这么多参数，这个是本人感觉最恶心的），你也可以先定义对象，然后一个一个的 set 进去（清晰也还可以，不过感觉没有 Builder 模式这样 高大上，^_^ ）。<br><br><b><i><u>装饰器模式</u></i></b><br>作用：可以动态的为一个类增加功能。了解了装饰器模式，会发现 Java IO 包 就是装饰器模式的典型实现，对理解 Java IO 包的结构很有帮助。<br>这个具体可以看下：<a href="//link.zhihu.com/?target=https%3A//www.wuhuachuan.com/visitor/learning/article/getArticleDetail%3Fid%3D2dc3a055-a6d0-4ed4-a815-7dac9b3a3d7b" class=" wrap external" target="_blank" rel="nofollow noreferrer">愿无岁月可回首<i class="icon-external"></i></a><br>这个没有在实际场景中用到，IO 包自己的工作中没接触到文件，所以也没用上战场。<br><br><b><i><u>策略模式</u></i></b><br>作用：涉及一组算法，可以让别人在不同的情况的方便切换。同时，策略和策略之间也是隔离的，一个策略的修改不会对其他策略有影响。具体实现可以看下：<a href="//link.zhihu.com/?target=https%3A//www.wuhuachuan.com/visitor/learning/article/getArticleDetail%3Fid%3Dfa5896a7-3690-4c8b-ab0d-21a7da3c6c6a" class=" wrap external" target="_blank" rel="nofollow noreferrer">愿无岁月可回首<i class="icon-external"></i></a><br><br>这个我在实际中有这样用到，我做的记账的功能，业务场景是这样的：<br>一个投资人买了一笔资产（就像你在p2p上投资了），那么你的资产就会上升，你的资金（余额）就会减少。然后，假如你要赎回了，那么你的资产就会减少，你的资金就会上升。<br><br>我的理解是，这一条条不同的逻辑，就像一个算法一个策略一样等别人调用，然后我就把每个逻辑包装成了一条策略，比如下图：<br><noscript>&lt;img src="https://pic4.zhimg.com/1dde82a056b37165815b13122ddfcd33_b.png" data-rawwidth="722" data-rawheight="392" class="origin_image zh-lightbox-thumb" width="722" data-original="https://pic4.zhimg.com/1dde82a056b37165815b13122ddfcd33_r.png"&gt;在上图中，有投资人购买赎回活期定期，有资产到期，有平台每日返回利息等，这些都对你的账目有影响。最后，每个策略用 @Component 定义好， 在其他的系统中， 用 @Autowire 引入，再调用主方法即可。 </noscript><img src="https://pic4.zhimg.com/1dde82a056b37165815b13122ddfcd33_b.png" data-rawwidth="722" data-rawheight="392" class="origin_image zh-lightbox-thumb lazy" width="722" data-original="https://pic4.zhimg.com/1dde82a056b37165815b13122ddfcd33_r.png" data-actualsrc="https://pic4.zhimg.com/1dde82a056b37165815b13122ddfcd33_b.png" data-lazyloaded="" style="width: 584px; height: 317.075px; display: block;">在上图中，有投资人购买赎回活期定期，有资产到期，有平台每日返回利息等，这些都对你的账目有影响。最后，每个策略用 @Component 定义好， 在其他的系统中， 用 @Autowire 引入，再调用主方法即可。 <br><br>那么，本人在用的时候，感觉就是，由于每个逻辑都隔离开了，然后我有 bug 就比较好找，比如说，投资人购买活期产品的时候，怎么利息不对了，然后我就能比较快的定位到某个策略上出了问题，这是一个。 另外，个人觉得还有一个好处就是，可以复用。比如说，最近新增加了一个债转的功能，就是你买了一笔资产，然后你不想要了，你要转让给别人，那么我在代码中实际就可以把这个逻辑分解成 你赎回，别人购买，那么，上面有两个策略马上就可以套用了，改起来比较好改。<br><br><b><i><u>观察者模式</u></i></b><br>作用：<b>有利于解耦</b>，有一个主题，一堆观察者，当主题发生变化的时候，会自动通知到观察者。<br>实现方式：在主题中维护了观察者列表的引用，当主题发生变化的时候，for循环不断的调用 观察者对应的响应方法。具体可以看下：<a href="//link.zhihu.com/?target=https%3A//www.wuhuachuan.com/visitor/learning/article/getArticleDetail%3Fid%3D0327a788-0597-4609-8e45-ff8925536f27" class=" wrap external" target="_blank" rel="nofollow noreferrer">愿无岁月可回首<i class="icon-external"></i></a><br><br>这个在项目中也有用到。应用场景是这样的：其实主要是为了完全解耦。因为我的记账模块在整个业务中不是特别重要的，像上面我提到的 先用@Component创建，然后别的模块用@Autowire引入，那么记账报错了怎么办，总不能因为一个不太重要的模块搞得整个业务跑不下去吧。基于这样，就用了一个 Spring 的事件机制。<b><i><u>事件机制的底层原理就是观察者模式</u></i></b>，有兴趣的同学可以看下 Java 的 Observable 和 Observer 类。 如果 spring 方向的同学也可以看下ApplicationContext （充当主题，因为它实现了ApplicationEventPublisher）；ApplicationListener 充当观察者，另外，把通知，也就是信息封装成了Event，例如使用了ApplicationEvent。<br><br>基于上面的原因，具体代码是这样用的：<br>在其他模块中，像这样把消息发出来：<br><noscript>&lt;img src="https://pic3.zhimg.com/ada20755c0a557813abe37a46d093c5a_b.png" data-rawwidth="1186" data-rawheight="626" class="origin_image zh-lightbox-thumb" width="1186" data-original="https://pic3.zhimg.com/ada20755c0a557813abe37a46d093c5a_r.png"&gt;然后我再这样用Listener接收这个消息：</noscript><img src="https://pic3.zhimg.com/ada20755c0a557813abe37a46d093c5a_b.png" data-rawwidth="1186" data-rawheight="626" class="origin_image zh-lightbox-thumb lazy" width="1186" data-original="https://pic3.zhimg.com/ada20755c0a557813abe37a46d093c5a_r.png" data-actualsrc="https://pic3.zhimg.com/ada20755c0a557813abe37a46d093c5a_b.png" data-lazyloaded="" style="width: 584px; height: 308.25px; display: block;">然后我再这样用Listener接收这个消息：<br><noscript>&lt;img src="https://pic1.zhimg.com/c8bcc200b1e85abec36f03256a23080c_b.png" data-rawwidth="1314" data-rawheight="564" class="origin_image zh-lightbox-thumb" width="1314" data-original="https://pic1.zhimg.com/c8bcc200b1e85abec36f03256a23080c_r.png"&gt;这个 transactionalEventListener 就相当于Listener，这里之所有用这个，主要是我想让别人调用我的代码的时候，他们执行ok了，事务提交了再调用我的（题外话了）。大家可以用 @EventListener  ，或者自己实现 ApplicationListener。</noscript><img src="https://pic1.zhimg.com/c8bcc200b1e85abec36f03256a23080c_b.png" data-rawwidth="1314" data-rawheight="564" class="origin_image zh-lightbox-thumb lazy" width="1314" data-original="https://pic1.zhimg.com/c8bcc200b1e85abec36f03256a23080c_r.png" data-actualsrc="https://pic1.zhimg.com/c8bcc200b1e85abec36f03256a23080c_b.png" data-lazyloaded="" style="width: 584px; height: 250.667px; display: block;">这个 transactionalEventListener 就相当于Listener，这里之所有用这个，主要是我想让别人调用我的代码的时候，他们执行ok了，事务提交了再调用我的（题外话了）。大家可以用 @EventListener  ，或者自己实现 ApplicationListener。<br>这个模式就是这样子了。<br><br><b><i><u>工厂模式</u></i></b><br>有利于解耦，而不是单纯的用 new 来进行紧耦合。其中又分为 简单工厂模式，工厂方法模式，抽象方法模式。具体可以参考下 <a href="//link.zhihu.com/?target=https%3A//www.wuhuachuan.com/visitor/learning/article/getArticleDetail%3Fid%3D7d47bd91-8cbe-4b95-a98e-b0c1118794f8" class=" wrap external" target="_blank" rel="nofollow noreferrer">愿无岁月可回首<i class="icon-external"></i></a><br><br>那么，上面那个截图其实就有点点简单工厂模式的味道。简单工厂模式，你可以理解为，根据传入参数的不同，创建不同的对象，像上面那个截图，也是根据传入的参数，来选择调用具体哪个对象的方法。<br><br>网上看资料说抽象工厂模式比较好，不过我的业务好像还用不到，或者说能用上我还不太会用，大家可以具体研究下这个抽象工厂模式。<br><br><b><i><u>单例模式</u></i></b><br>单例模式如果只是考虑饿汉懒汉，如果只是先 static 创建好对象，然后再 getInstance() 得到这个对象，那么还是比较简单的。但是这样其实不太适合用在多线程环境下。在多线程环境下，创建的时候需要加入  synchronized，如果效率要求高一点，那么可以使用 lock + 双重判断来解决。<br>具体可以看下：<a href="//link.zhihu.com/?target=https%3A//www.wuhuachuan.com/visitor/learning/article/getArticleDetail%3Fid%3Df5c93b51-7ae5-4d53-aadd-4700ac562ed8" class=" wrap external" target="_blank" rel="nofollow noreferrer">愿无岁月可回首<i class="icon-external"></i></a><br><br>这个模式在项目中的代码写过这样的：<br><noscript>&lt;img src="https://pic2.zhimg.com/61e849147984520fa0148fbbad1fedcd_b.png" data-rawwidth="794" data-rawheight="714" class="origin_image zh-lightbox-thumb" width="794" data-original="https://pic2.zhimg.com/61e849147984520fa0148fbbad1fedcd_r.png"&gt;就是说很多时候我们可能用 gson 解析或者转化，一个 工具类就没必要 new Gson() 了。</noscript><img src="https://pic2.zhimg.com/61e849147984520fa0148fbbad1fedcd_b.png" data-rawwidth="794" data-rawheight="714" class="origin_image zh-lightbox-thumb lazy" width="794" data-original="https://pic2.zhimg.com/61e849147984520fa0148fbbad1fedcd_r.png" data-actualsrc="https://pic2.zhimg.com/61e849147984520fa0148fbbad1fedcd_b.png" data-lazyloaded="" style="width: 584px; height: 525.159px; display: block;">就是说很多时候我们可能用 gson 解析或者转化，一个 工具类就没必要 new Gson() 了。<br>不过像这种都是蛮小的细节，当时写这个的时候，也主要也是在看这个模式，然后想想项目中有哪些地方可以用上，就硬搞了这个。^_^。 我想了想，好像也没啥多线程问题，项目一启动就创建了不就完事了么，就这样写了，哈哈。<br><br><br>以后有其他模式总结了再更。。。有错误也请指出，谢谢了。
</div>